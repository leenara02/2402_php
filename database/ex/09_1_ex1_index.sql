-- 인덱스 : 목차 (우리가 검색하고자 사용하는 쿼리에 부여하는 기능)
-- 검색성능의 속도를 높여줌 (SELECT의 성능)
-- 오름차순이 디폴트임.
-- 클러스터인덱스는 PK에만 지정되기 때문에 하나만 생성
-- 보조인덱스는 개발자가 만들기 때문에 여러개 생성될 수 있음
-- 인덱스가 잇고없고 에 따라 속도가 90% 이상 빨라짐.
-- 조회하는 숫자를 획기적으로 줄일 수 있음
-- 인덱스를 위해 10%에 해당하는 추가 저장공간 필요
-- 인덱스르를 관리하기위한 추가작업이 필요하다.
-- 성능테스트해야되고, 셀렉트가 얼마나 빨라졌는가
-- 인서트문쿼리 관리
-- 인서트, 업데이트, 딜리트 사용비율을 통계 내야됨.
-- 데이터 하나가 지워지면 B트리 구조를 다시 짜야되기 때문에 주의
-- 인덱스에 성능이 저하되면 쿼리튜닝 해야됨.
-- 검색하고자 하는 데이터가 테이블의 10~15%인하 일 경우 가장 효율적.
-- 각각의 값들이 전체데이터에서 차지하는 비율이 10~15%일때 가장 효율적.
-- 속도향상을 위해서는 쿼리를 좀더 효율적으로 짜고, 인덱스는 최후의 수단으로 사용
-- 인덱스를 추가 했다면 대량의 데이터로 CRUD를 테스트 해야됨
-- 사용하지않는 인덱스는 제거해야됨. (저장공간을 많이 차지하기 때문에)
-- 마리아DB는 FK를지정한 열은 자동으로 FK인덱스가생성된다. (오라클은 기본으로 생성안됨)

-- 어떨때사용?
-- 규모가 작지않은 테이블
-- INSERT, UPDATE, DELET가 자주 발생하지않는 컬럼 (유저테이블)
-- JOIN,WHERE.ORDERBY 같이 조건에 사용되는 컬럼
-- 데이터가 중복도가 낮은 컬럼 (이름 같은경우)
-- 취미,이름 같은것은 처음 설계할때부터 인덱스를 부여할 수도 있음

-- INDEX

-- INDEX 확인
SHOW INDEX FROM employees;

-- 0.125초
SELECT * FROM employees WHERE first_name = 'Saniya';

-- INDEX 생성
-- 0.000초
ALTER TABLE employees ADD INDEX idx_employees_first_name (first_name);

-- 쿼리문이 복잡할수록 인덱스로 묶었을때 속도가 많이 향상됨.
-- 속도가 느리다면 쿼리튜닝을 먼저 해보고, 안될경우 인덱스 사용

-- INDEX 삭제
DROP INDEX idx_employees_first_name ON employees;







